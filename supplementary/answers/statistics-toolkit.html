<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>statistics-toolkit</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="statistics-toolkit_files/libs/clipboard/clipboard.min.js"></script>
<script src="statistics-toolkit_files/libs/quarto-html/quarto.js"></script>
<script src="statistics-toolkit_files/libs/quarto-html/popper.min.js"></script>
<script src="statistics-toolkit_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="statistics-toolkit_files/libs/quarto-html/anchor.min.js"></script>
<link href="statistics-toolkit_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="statistics-toolkit_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="statistics-toolkit_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="statistics-toolkit_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="statistics-toolkit_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  
</div>
<main class="content" id="quarto-document-content">



<p>I came across the decision tree for inferential statistics through a post shared by colleagues. I truly appreciate your effort to make statistics more accessible to HCI researchers. However, I have several concerns regarding some of the terminology and specific guidelines presented in the figure. I hope my feedback will encourage the authors to revise the figure and include necessary flags and warnings.</p>
<section id="parametric-vs.-nonparametric-data" class="level4">
<h4 class="anchored" data-anchor-id="parametric-vs.-nonparametric-data">Parametric vs.&nbsp;Nonparametric Data</h4>
<p>The terms and “parametric” or “nonparametric” refer to the statistical methods used to analyze the data — they are not inherent characteristics of the collected data. If when data violate the assumptions of ANOVA or linear regression, one may still be able to use alternative parametric methods to analyze the data, such as to use generalized linear models.</p>
<p>I want emphasize this point for another reason. By classifying the data as parametric or nonparametric, we automatically make a “prescription” of which statistical method is valid and which is not, which is generally a bad practice. For example, see <a href="https://www.cs.uic.edu/~wilkinson/Publications/stevens.pdf">Vellman and Wilkinson</a> for a detailed argumentation about why data typologies can be misleading if they are not appropriately used. In my lectures, I used to point to <a href="https://www.amazon.com/Serious-Stat-advanced-statistics-behavioral/dp/0230577180">Baguley’s</a> recommendations regarding the criteria one needs to consider for choosing among statistical methods:</p>
<p><em>“An alternative approach – that advocated here – is to consider a range of factors of data that impact on the statistical model you are considering. These factors include whether data are discrete or continuous, but other factors, such as the probability distribution being assumed, the size of the sample and what the model is being used for, are also important.”</em> (Page 6).</p>
<p>Unfortunately, it is not always easy to prescribe a set of rules for making decisions. Personally, I often use simulations to test the robustness of different methods when model assumptions are violated.</p>
<p><em>(Minor comment: Integer ratings, counts, and Likert items make discrete values — why are they characterized as continuous here?)</em></p>
</section>
<section id="the-aligned-rank-transform" class="level4">
<h4 class="anchored" data-anchor-id="the-aligned-rank-transform">The Aligned Rank Transform</h4>
<p>For multi-factor designs and as long as data are classified as “nonparametric” (e.g., for counts, single Likert items, and skewed distributions that don’t pass a normality test), the decision tree naturally leads to the use of the Aligned Rank Transform (ART). Unfortunately, as we show in our <a href="https://www.journalovi.org/2024-tsandilas-ranktransforms">JoVI submission</a>, ART is actually inappropriate for exactly this type of data.</p>
<p>Yes, this may sound counterintuitive, but we found that ART’s alignment method only works under very strict linearity assumptions and also fails under discrete data (see, for example, <a href="https://www.journalovi.org/2024-tsandilas-ranktransforms/supplementary/examples-case-studies/6-Case-studies/Rosso-et-al-23/Rosso-et-al-23.html">this real example</a>). Interestingly, using regular ANOVA with such data is actually safer than using ART. Check out <a href="https://www.journalovi.org/2024-tsandilas-ranktransforms/#recommendations">our recommendations</a> for more details (we hope to further improve them in an updated version).</p>
<p>However, I should note that the article is still under review and ART’s authors have not yet acknowledged these problems. You can follow the ongoing open discussions <a href="https://github.com/journalovi/2024-tsandilas-ranktransforms/issues">here</a>, where we provide additional explanation about why and how ART fails.</p>
</section>
<section id="meaning-of-95-confidence-intervals" class="level4">
<h4 class="anchored" data-anchor-id="meaning-of-95-confidence-intervals">Meaning of 95% Confidence Intervals</h4>
<p>The heuristics given in the figure about the interpretation of confidence intervals is not correct. Please, see <a href="https://pubmed.ncbi.nlm.nih.gov/18991332/">Cumming and Finch</a> for an explanation. In the general case, the correct approach is to construct the confidence interval of the difference and check whether this includes zero.</p>
<p>Also notice that null hypothesis significance testing does not allow for rejecting H1. That said, one could specify a minimal difference of interest <span class="math inline">\(\delta\)</span> and reject H1 if the confidence interval of the difference resides below this <span class="math inline">\(\delta\)</span> (which may require a large sample size). But this is not what we read on the image.</p>
</section>
<section id="interaction-effects" class="level4">
<h4 class="anchored" data-anchor-id="interaction-effects">Interaction Effects</h4>
<p>I am not familiar with the terms <em>exponential</em> and <em>antagonistic</em> interaction. In <a href="https://www.journalovi.org/2024-tsandilas-ranktransforms/#interpreting-interactions">our submission</a>, however, we make a distinction between <em>removable</em> and <em>non-removable</em> interactions, following the analysis of <a href="https://link.springer.com/article/10.3758/BF03197461">Loftus</a>.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>