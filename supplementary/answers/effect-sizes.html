<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>effect-sizes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="effect-sizes_files/libs/clipboard/clipboard.min.js"></script>
<script src="effect-sizes_files/libs/quarto-html/quarto.js"></script>
<script src="effect-sizes_files/libs/quarto-html/popper.min.js"></script>
<script src="effect-sizes_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="effect-sizes_files/libs/quarto-html/anchor.min.js"></script>
<link href="effect-sizes_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="effect-sizes_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="effect-sizes_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="effect-sizes_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="effect-sizes_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#relationship-between-effect-size-estimates-and-p-values" id="toc-relationship-between-effect-size-estimates-and-p-values" class="nav-link active" data-scroll-target="#relationship-between-effect-size-estimates-and-p-values">Relationship between effect-size estimates and <em>p</em>-values</a></li>
  <li><a href="#observing-how-art-confounds-effects-in-heavy-tailed-distributions" id="toc-observing-how-art-confounds-effects-in-heavy-tailed-distributions" class="nav-link" data-scroll-target="#observing-how-art-confounds-effects-in-heavy-tailed-distributions">Observing how ART confounds effects in heavy-tailed distributions</a></li>
  <li><a href="#estimation-of-non-null-effects" id="toc-estimation-of-non-null-effects" class="nav-link" data-scroll-target="#estimation-of-non-null-effects">Estimation of non-null effects</a></li>
  <li><a href="#ordinal-data" id="toc-ordinal-data" class="nav-link" data-scroll-target="#ordinal-data">Ordinal data</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">



<p>I found some time to add some data on effects sizes to respond to <span class="citation" data-cites="mutrussel">@mutrussel</span>.</p>
<p>Code for these analyses is provided here:</p>
<section id="relationship-between-effect-size-estimates-and-p-values" class="level3">
<h3 class="anchored" data-anchor-id="relationship-between-effect-size-estimates-and-p-values">Relationship between effect-size estimates and <em>p</em>-values</h3>
<p><strong>If we keep the sample size fixed</strong>, there is a clear relationship between <em>p</em>-values and estimates of effects sizes. For example, the following graph show the relationship between the logarithm of the <em>p</em>-values and the partial <span class="math inline">\(\eta^2\)</span> (eta squared) returned by ANOVA for the first factor of a 4x3 repeated-measures design when <span class="math inline">\(n = 20\)</span>.</p>
<p><img src="pvalue-eta-squared.png" class="img-fluid"></p>
<p>Thus, large discrepancies in <em>p</em>-values across different methods (particularly in orders of magnitude) also translate to discrepancies in their effect-size estimates.</p>
</section>
<section id="observing-how-art-confounds-effects-in-heavy-tailed-distributions" class="level3">
<h3 class="anchored" data-anchor-id="observing-how-art-confounds-effects-in-heavy-tailed-distributions">Observing how ART confounds effects in heavy-tailed distributions</h3>
<p>Now, let’s demonstrate ART’s issues by observing the estimated partial <span class="math inline">\(\eta^2\)</span> for the first factor <span class="math inline">\(X_1\)</span>, as we increase the effect on the second factor <span class="math inline">\(X_2\)</span>. To do so, we increase the model coefficient <span class="math inline">\(a_2\)</span>, while <span class="math inline">\(a_1 = 0\)</span> and <span class="math inline">\(a_{12} = 0\)</span>. Below, we show results for log-normal distributions with <span class="math inline">\(n=20\)</span> and 300 data points for each level of <span class="math inline">\(a_2\)</span>:</p>
<p><img src="plot-no-effect.png" class="img-fluid"></p>
<p>The ground-truth method is the ideal approach of using ANOVA on the latent normal scale. We observe that ART is the only method affected by an increase in the magnitude of the effect on <span class="math inline">\(X_2\)</span>. PAR’s effect-size estimates for <span class="math inline">\(X_1\)</span> remain unaffected. This clearly illustrates that ART’s failure is due to its alignment mechanism, which confounds effects under such distributions.</p>
</section>
<section id="estimation-of-non-null-effects" class="level3">
<h3 class="anchored" data-anchor-id="estimation-of-non-null-effects">Estimation of non-null effects</h3>
<p>Now, let’s examine what happens when there is actually an effect on <span class="math inline">\(X_1\)</span>, by setting <span class="math inline">\(a_1 = 1\)</span>:</p>
<p><img src="plot-with-effect.png" class="img-fluid"></p>
<p>We observe that PAR is not ideal for such data, as it consistently underestimates effects. Note that ART tends to underestimate effects when <span class="math inline">\(a_2 = 0\)</span>. As <span class="math inline">\(a_2\)</span> increases, its effect-size estimates become noisy (the variance increases) and show an overall tendency to increase. INT’s precision is also affected when <span class="math inline">\(a_2 = 8\)</span>, slightly tending to underestimate effect sizes.</p>
</section>
<section id="ordinal-data" class="level3">
<h3 class="anchored" data-anchor-id="ordinal-data">Ordinal data</h3>
<p>Finally, we examine how the methods behave under an ordinal scale with 5 levels, when all effects are null. The following graphs show the partial <span class="math inline">\(\eta^2\)</span> for the first factor <span class="math inline">\(X_1\)</span> as the sample size <span class="math inline">\(n\)</span> increases (300 data points per <span class="math inline">\(n\)</span>):</p>
<p><img src="plot-ordinal.png" class="img-fluid"></p>
<p>We observe ART’s estimates are highly noisy. Even when sample sizes become large, the method frequently fails to provide precise estimates.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>